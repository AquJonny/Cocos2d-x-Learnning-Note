1.CC_SYNTHESIZE_RETAIN与CC_SYNTHESIZE
  相同点：
        A.声明对象的set()和get()方法
        B.得到的是一个autorelease的对象
        C.这个对象的生命周期为全局，可以调用的范围看声明的区域
  
  不同点：
        A.CC_SYNTHESIZE_RETAIN方法在创建对象之后会调用retain为其的引用计数＋1
          ＝>处理完成之后不会因为引用计数－！而等于0，被自动释放
            ＝>也因此需要在不再使用的时候使用CC_SAFE_RELEASE_NULL方法去释放掉
        B.cocos2d::Vector<T> 并不是 cocos2d::Object 的子类，
          所以不要像使用其他cocos2d类一样来用retain/release和引用计数内存管理。
          
2.关于update方法
  每个节点(Layer，Sprite)都有各自的update方法，编程时需要重写原本父类的函数。
  通过this->scheduleUpdate()方法登录，让每一帧都调用该节点的update方法。
  
3.关于虚函数(virtual)
  虽然类中可以定义虚函数（并没有实际去实现这个函数而只是单纯的进行了声明）
  但是子类无法直接去调用父类的虚函数，必须在当前类中去对父类声明的虚函数进行具体的实现。
  但是A类声明了虚函数，B类继承了A类并完善了虚函数的实现方法，此时C类继承B类的话，就可以调用
  A类声明的虚函数了，但是，实际调用的是在B类中已经完善了的虚函数。
            
4.关于创建对象
  使用NEW活着CREATE创建的对象，由于是autorelease的对象的缘故。在主处理完成时会被自动释放。
  因此，在别的方法中想再次使用这个对象的话，有两种方法：
  A.在创建完成之后需要调用Retain()方法为其引用计数＋1
  B.利用CC_SYNTHESIZE_RETAIN方法创建全局性质的变量，NEW/CREATE之后获得的新对象，set到全局变量中
    这样在其他的方法中就可以通过访问全局变量，来利用创建的对象了
  以上两种方法创建的对象都需要在不再使用的时候使用CC_SAFE_RELEASE_NULL方法去释放掉
    
6.常用的获取精灵信息的一些方法
  A.获取／设定坐标点（X，Y）
    getPosition／setPosition
    
  B.获取／设定X轴坐标点（Y轴同理）
    getPositionX／setPositionX
  
  C.获取／设定精灵的锚点
    getAnchorPoint／setAnchorPoint
  
  D.获取精灵所在的矩形区域（X，Y，长，宽）＊X，Y是精灵左下角的位置
    getBoundingBox
    ＊判断一个点是否在精灵所在区域内
      BoundingBox.containsPoint(Point)
  
9.背景音乐和效果音
  使用CocosDenshion::SimpleAudioEngine类去实现，因为不属于Cocos2d的子类，需要添加头文件
  playBackgroundMusic播放背景音乐；playEffect播放音效
  注意：A.播放背景音乐之后，需要在场景结束时刻调用CocosDenshion::SimpleAudioEngine::end()方法进行结束处理
         ＊不调用貌似也没问题？？？
       B.设置背景音乐之后，需要注意在游戏被最小化以及被恢复时候的背景音乐控制（一般为暂停&恢复）
         在AppDelegate.cpp的
           applicationDidEnterBackground  被最小化
           applicationWillEnterForeground 丛最小化被恢复
         中追加pauseBackgroundMusic()暂停，resumeBackgroundMusic()恢复的处理
         
10.关于onEnterTransitionDidFinish方法
  该方法为场景加载完毕后只运行一次的预处理方法，为Layer类既存处理
  可以通过重载的方式，
  保留原本处理内容（添加Layer::onEnterTransitionDidFinish()调用父类原本的处理）
  并追加自己需要的预处理内容：
    背景音乐的播放开关
    场景内容的设定
    etc...
  ＊该处理会在 构造，create，init等方法之后，被director调用

11.CC_CALLBACK_0系列宏
   首先,CC_CALLBACK_0系列有以下4个成员
     CC_CALLBACK_0
     CC_CALLBACK_1
     CC_CALLBACK_2
     CC_CALLBACK_3

   这系列的宏是对std::bind的一种封装,关于bind:
   bind是一组用于函数绑定的模板。在对某个函数进行绑定时，可以指定部分参数或全部参数，也可以不指定任何参数，还可以调整各个参数间的顺序。对于未指定的参数，可以使用占位符_1、_2、_3来表示。_1表示绑定后的函数的第1个参数，_2表示绑定后的函数的第2个参数，其他依次类推。(_1的完整写法std::placeholders::_1)

   而其末尾的数字0~3的含义，则是在调用该函数时候需要传入的参数数量.

   举例而言:

   void callback(int a, int b, int c)
   ↓
   CC_CALLBACK_0(callback, this, 10, 20, 30);
   *调用时候不需要再额外传递参数
   ↓
   CC_CALLBACK_1(callback, this, _1, 20, 30);
   *调用时候需要将_1占位符代表的参数传递给函数
   *_1在写代码时候可以被省略

  
